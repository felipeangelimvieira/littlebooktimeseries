[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "book",
    "section": "",
    "text": "Preface\nThis is a Quarto book.\nTo learn more about Quarto books visit https://quarto.org/docs/books.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "content/pt/01_intro/index.html",
    "href": "content/pt/01_intro/index.html",
    "title": "1  Introdução",
    "section": "",
    "text": "Em modelos de regressão e classificação básicos, supomos que os dados são i.i.d: variaveis aleatórias independentes e identicamente distribuidas. Ou seja, a ordem que observamos os dados não tem nenhum impacto em nossa habilidade de prever quais serão as próximas observações.\nVamos considerar um experimento simples: temos uma caixa com bolas pretas e vermelhas dentro. Digamos que as bolas pretas valem 1 e as bolas vermelhas valem 0. Queremos descobrir qual a quantidade de pontos vamos ter na próxima rodada.\n\n\n\nBolas pretas e vermelhas\n\n\nSe as bolas estão distribuidas aleatóriamente dentro da caixa, podemos esperar ver algo como a seguinte sequência de pontos:\n\\[\n\\{0, 1, 1, 0, 1, 0, 0, \\dots \\}\n\\]\nNesse caso, a ordem dos pontos não importa. Não importa o que vimos até então; a próxima bola que vamos tirar da caixa é independente das bolas que já tiramos.\nVamos supor um caso ligeiramente diferente. Agora, as bolas estão organizadas em blocos: primeiro todas as bolas pretas, depois todas as bolas vermelhas, depois todas as bolas pretas de novo, e assim por diante. Nesse caso, podemos esperar ver algo como:\n\\[\n\\{1, 1, 1, 0, 0, 0, 1, 1, 1, \\dots \\}\n\\]\nNesse caso, a ordem dos pontos importa. Se vimos muitas bolas pretas recentemente, é mais provável que vejamos uma bola preta na próxima rodada. A próxima bola que vamos tirar da caixa depende das bolas que já tiramos. Esse é um caso básico de aplicação de modelos de previsão de séries temporais.\nEsse livro é uma introdução prática a modelos de séries temporais, com objetivo de dar contexto das ferramentas mais relevantes em 3h de leitura.\nO conteúdo está organizado nas seguintes seções:\n\nIntrodução a séries temporais:\n\nModelo Naive, Modelo Naive sazonal\nSéries integradas, diferenciação e estacionariedade\nModelo de Suavização Exponencial (Exponential Smoothing)\nModelos autoregressivos (AR)\nMétricas de avaliação de modelos de séries temporais\nEngenharia de features para séries temporais\n\nModelos avançados e caso de uso\n\nForecast com modelos de Machine Learning\nForecast com modelos fundacionais\nPrevisão de vendas totais agregadas\nPrevisão de vendas por região e modelos globais\nPrevisão hierárquica e reconciliação\n\nCustomização de modelos com sktime\n\nComo customizar e criar modelos em sktime\nCriando um wrapper de biblioteca externa",
    "crumbs": [
      "Part I: Básico",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introdução</span>"
    ]
  },
  {
    "objectID": "content/pt/part1/index.html",
    "href": "content/pt/part1/index.html",
    "title": "1  Definição do problema",
    "section": "",
    "text": "Em modelos de regressão e classificação básicos, supomos que os dados são i.i.d: variaveis aleatórias independentes e identicamente distribuidas. Ou seja, a ordem que observamos os dados não tem nenhum impacto em nossa habilidade de prever quais serão as próximas observações.\nVamos considerar um experimento simples: temos uma caixa com bolas pretas e vermelhas dentro. Digamos que as bolas pretas valem 1 e as bolas vermelhas valem 0. Queremos descobrir qual a quantidade de pontos vamos ter na próxima rodada.\n\n\n\nBolas pretas e vermelhas\n\n\nSe as bolas estão distribuidas aleatóriamente dentro da caixa, podemos esperar ver algo como a seguinte sequência de pontos:\n\\[\n\\{0, 1, 1, 0, 1, 0, 0, \\dots \\}\n\\]\nNesse caso, a ordem dos pontos não importa. Não importa o que vimos até então; a próxima bola que vamos tirar da caixa é independente das bolas que já tiramos.\nVamos supor um caso ligeiramente diferente. Agora, as bolas estão organizadas em blocos: primeiro todas as bolas pretas, depois todas as bolas vermelhas, depois todas as bolas pretas de novo, e assim por diante. Nesse caso, podemos esperar ver algo como:\n\\[\n\\{1, 1, 1, 0, 0, 0, 1, 1, 1, \\dots \\}\n\\]\nNesse caso, a ordem dos pontos importa. Se vimos muitas bolas pretas recentemente, é mais provável que vejamos uma bola preta na próxima rodada. A próxima bola que vamos tirar da caixa depende das bolas que já tiramos. Esse é um caso básico de aplicação de modelos de previsão de séries temporais.\nConsiderando que cada observação é indexada por uma variável temporal, podemos definir uma série temporal como uma sequência de observações ordenadas no tempo. Exemplos comuns de séries temporais incluem:\n\nVarejo: vendas diárias, semanais ou mensais de um produto\nFinanças: preços diários de ações, taxas de câmbio\nSaúde: número diário de novos casos de uma doença\nClima: temperatura diária, precipitação mensal\n\nEsse livro é uma introdução prática a modelos de séries temporais, com objetivo de dar contexto das ferramentas mais relevantes em 3h de leitura.\nO conteúdo está organizado nas seguintes seções:\n\nIntrodução a séries temporais:\n\nModelo Naive, Modelo Naive sazonal\nSéries integradas, diferenciação e estacionariedade\nModelo de Suavização Exponencial (Exponential Smoothing)\nModelos autoregressivos (AR)\nMétricas de avaliação de modelos de séries temporais\nEngenharia de features para séries temporais\n\nModelos avançados e caso de uso\n\nForecast com modelos de Machine Learning\nForecast com modelos fundacionais\nPrevisão de vendas totais agregadas\nPrevisão de vendas por região e modelos globais\nPrevisão hierárquica e reconciliação\n\nCustomização de modelos com sktime\n\nComo customizar e criar modelos em sktime\nCriando um wrapper de biblioteca externa",
    "crumbs": [
      "Part I: Básico",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Definição do problema</span>"
    ]
  },
  {
    "objectID": "content/pt/part1/naive.html",
    "href": "content/pt/part1/naive.html",
    "title": "2  Primeiro passos com sktime e modelo Naive",
    "section": "",
    "text": "2.1 Exemplo prático com sktime\nConsiderando o nosso exemplo da caixa com bolas pretas e vermelhas, um modelo simples para prever a próxima bola que vamos tirar da caixa é o Modelo Naive.\nExistem algumas versões de modelo naive:\nEsse modelo é simples, mas é extremamente eficaz e dificil de ser vencido em muitos casos. No cenário onde os dados não vêm organizados em nenhuma ordem específica, a melhor aposta que podemos fazer é o valor médio das bolas no histórico recente.\nVamos ver como fazer um forecast simples com sktime, usando o modelo Naive.\nAqui, baixamos o dataset simples que vem na biblioteca desse repositório.\nfrom tsbook.datasets.simple import SimpleDataset\n\n\ndataset = SimpleDataset(True)\ny = dataset.load(\"y\")\n\ny.head()\n\n\n\n\n\n\n\n\npoints\n\n\n\n\n2021-01-01\n0\n\n\n2021-01-02\n0\n\n\n2021-01-03\n0\n\n\n2021-01-04\n1\n\n\n2021-01-05\n1\nEsse é um dataset simples com uma série temporal mensal. Vamos dividir os dados em treino e teste, usando os últimos 36 meses como teste. Para isso, devemos respeitar a ordem temporal dos dados.\nA função temporal_train_test_split faz isso para nós.\nfrom sktime.forecasting.model_selection import temporal_train_test_split\ny_train, y_test = temporal_train_test_split(y, test_size=36)\nTambém temos uma função de plotagem simples para visualizar séries temporais.\nfrom sktime.utils.plotting import plot_series\n\nplot_series(y, labels=[\"Observações\"])",
    "crumbs": [
      "Part I: Básico",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Primeiro passos com sktime e modelo Naive</span>"
    ]
  },
  {
    "objectID": "content/pt/part1/naive.html#exemplo-prático-com-sktime",
    "href": "content/pt/part1/naive.html#exemplo-prático-com-sktime",
    "title": "2  Primeiro passos com sktime e modelo Naive",
    "section": "",
    "text": "2.1.1 Criando o modelo\nNo sktime, os modelos são usados em 3 passos:\n\nInicialização (__init__): aqui, definimos os hiperparâmetros do modelo. Pense nessa parte como a configuração do modelo.\nTreinamento (fit): aqui, o modelo aprende com os dados de treino.\nPrevisão (predict): com esse método, o modelo faz previsões para os dados futuros.\n\nQuando inicializamos o modelo em um notebook, o sktime mostra uma ilustração do modelo, o que é útil para entender o que está acontecendo “por baixo dos panos”. Em casos mais complexos com composição de modelos, isso pode ser útil para ilustrar o que estamos fazendo para outros cientistas.\n\nfrom sktime.forecasting.naive import NaiveForecaster\n\nmodel = NaiveForecaster(strategy=\"last\")\nmodel\n\nNaiveForecaster()Please rerun this cell to show the HTML repr or trust the notebook.NaiveForecaster?Documentation for NaiveForecasterNaiveForecaster()\n\n\nAo treinar o modelo, passamos dados de treinamento.\n\nmodel.fit(y_train)\n\nNaiveForecaster()Please rerun this cell to show the HTML repr or trust the notebook.NaiveForecaster?Documentation for NaiveForecasterNaiveForecaster()\n\n\nPara a previsão, temos que passar um argumento obrigatório: fh, abreviatura de “forecasting horizon” (horizonte de previsão). Tipicamente passamos um fh relativo, ou seja, no formato de uma lista\n\nmodel.predict(fh=[1,2,3,4])\n\n\n\n\n\n\n\n\npoints\n\n\n\n\n2021-03-06\n1.0\n\n\n2021-03-07\n1.0\n\n\n2021-03-08\n1.0\n\n\n2021-03-09\n1.0\n\n\n\n\n\n\n\nOnde cada número representa o número de períodos à frente que queremos prever. Também podemos passar o fh como um índice de tempo absoluto, que é o que faremos aqui. Vamos passar o índice de tempo do conjunto de teste.\n\ny_pred = model.predict(fh=y_test.index)\n\nplot_series(y_train, y_test, y_pred, labels=[\"Treino\", \"Teste\", \"Previsão\"])\n\n\n\n\n\n\n\n\n\n\n2.1.2 Ajustando hiperparâmetros\nPara alterar hiperparametros de um modelo já existente, podemos usar o método set_params, que modifica in-place os hiperparâmetros do modelo.\n\nmodel.set_params(\n    strategy=\"mean\",\n    window_length=12,\n)\n\nmodel.fit(y_train)\ny_pred = model.predict(fh=y_test.index)\n\n\nplot_series(y_train, y_test, y_pred, labels=[\"Treino\", \"Teste\", \"Previsão\"])\n\n\n\n\n\n\n\n\nPodemos também testar o Naive sazonal, que repete a última observação de 6 períodos atrás.\n\nmodel.set_params(\n    sp=6,\n    strategy=\"last\"\n\n)\nmodel.fit(y_train)\ny_pred = model.predict(fh=y_test.index)\nplot_series(y_train, y_test, y_pred, labels=[\"Treino\", \"Teste\", \"Previsão\"])\n\n\n\n\n\n\n\n\nClaro, como esse exemplo é muito simples, o modelo naive sazonal captura perfeitamente a sazonalidade dos dados. No entanto, vamos ver no próximo capítulo um caso de uso mais realista, com dados de varejo, e estudaremos modelos mais avançados.",
    "crumbs": [
      "Part I: Básico",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Primeiro passos com sktime e modelo Naive</span>"
    ]
  },
  {
    "objectID": "content/pt/part1/statistical_models_differentiation.html",
    "href": "content/pt/part1/statistical_models_differentiation.html",
    "title": "3  Modelos estatísticos clássicos e diferenciação",
    "section": "",
    "text": "3.1 Importando dados\nNesse capítulo, vamos começar a usar um dataset mais realista, com dados simulando vendas diárias de uma empresa de varejo.\nVamos aprender os seguintes pontos:\nPara acessar os dados, vamos usar a classe SyntheticRetail da biblioteca tsbook, que contém dados simulados de vendas diárias de uma empresa de varejo.\nfrom tsbook.datasets.retail import SyntheticRetail\nfrom sktime.utils.plotting import plot_series\n\ndataset = SyntheticRetail(\"univariate\")\ny_train, y_test = dataset.load(\"y_train\", \"y_test\")\n\nplot_series(y_train, y_test, labels=[\"Treino\", \"Teste\"])\nOs dados são diários, e vemos que sempre positivos. Também notamos que existe alguma sazonalidade, aparentemente algo mensal e anual, que aumenta de magnitude ao longo do tempo.\nAlgo que deve chamar a atenção nesse gráfico é que a magnitude da série temporal está aumentando ao longo do tempo. Isso não deve passar desapercebido, pois é um ponto importante para entendermos o que vem a seguir.",
    "crumbs": [
      "Part I: Básico",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Modelos estatísticos clássicos e diferenciação</span>"
    ]
  },
  {
    "objectID": "content/pt/part1/statistical_models_differentiation.html#séries-estacionárias",
    "href": "content/pt/part1/statistical_models_differentiation.html#séries-estacionárias",
    "title": "3  Modelos estatísticos clássicos e diferenciação",
    "section": "3.3 Séries estacionárias",
    "text": "3.3 Séries estacionárias\nO conceito de estacionariedade é fundamental em séries temporais. Uma série temporal é dita estacionária se suas propriedades estatísticas, como média, variância e autocovariância, são constantes ao longo do tempo, não importando a janela e quando ela é observada.\n\nMais precisamente, se \\(Y(t)\\), onde \\(t\\) é o indice temporal, então dizemos que ela é estacionária se:\n\\[\nP(Y(t_{start}:t_{end})) = P(Y(t_{start}+k:t_{end}+k)), \\quad \\forall k, t_{start}, t_{end} \\in \\mathbb{Z}\n\\]\n\nClaramente, a série temporal que estamos analisando não é estacionária. Basta percebermos que para valores maiores de \\(t\\), a média e a variância são maiores.\nO aumento da média da série ao longo do tempo é chamado de tendência. A tendência é um padrão de longo prazo na série temporal, e um grande desafio para previsões de longo prazo.\nExistem definições mais “suaves” de estacionariedade, como a estacionariedade fraca, que requer apenas que propriedades como média e autovariância sejam constantes ao longo do tempo.\nNo fundo, o que nos interessa mais é ter uma série temporal que seja “fácil”de modelar. Para alguns algoritmos, como Naive, é importante que ela seja o mais próxima possível de estacionária. Veja abaixo o problema geraodo quando aplicamos o modelo Naive diretamente na série temporal original.\n\nfrom sktime.forecasting.naive import NaiveForecaster\n\nnaive = NaiveForecaster(strategy=\"mean\", window_length=24)\nnaive.fit(y_train)\ny_pred = naive.predict(fh=y_test.index)\n\nplot_series(y_train, y_test, y_pred, labels=[\"Treino\", \"Teste\", \"Previsão Naive\"])\n\n\n\n\n\n\n\n\n\n3.3.1 Diferenciação\nUma técnica simples e eficaz para lidar com séries não estacionárias é a diferenciação. Calculamos:\n\\[\nY'(t) = Y(t) - Y(t-1)\n\\]\ne fazemos previsões em \\(Y'(t)\\) ao invés de \\(Y(t)\\). Para obter a previsão de \\(Y(t)\\), precisamos fazer o processo inverso: somar a previsão de \\(Y'(t)\\) com o valor anterior de \\(Y(t-1)\\).\n\\[\n\\hat{Y(t)} = \\hat{Y'}(t) + \\hat{Y}(t-1), \\quad \\hat{Y}(0) \\text{ conhecido}\n\\]\nCom sktime, isso é extremamente fácil. Aqui, vamos usar um transformador chamado Differencer. Transformadores fazem alterações nos dados, mas não fazem previsões. Eles são usados para pré-processar ou pós processar os dados antes de aplicar um modelo de previsão.\n\nfrom sktime.transformations.series.difference import Differencer\ndiff = Differencer()\ndiff.fit(y_train)\n\nDifferencer()Please rerun this cell to show the HTML repr or trust the notebook.Differencer?Documentation for DifferencerDifferencer()\n\n\n\ny_train_diff = diff.transform(y_train)\n\nplot_series(y_train, y_train_diff, labels=[\"Original\", \"Diferenciado\"])",
    "crumbs": [
      "Part I: Básico",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Modelos estatísticos clássicos e diferenciação</span>"
    ]
  },
  {
    "objectID": "content/pt/part1/statistical_models_differentiation.html#criando-um-pipeline-com-diferenciação-e-naive",
    "href": "content/pt/part1/statistical_models_differentiation.html#criando-um-pipeline-com-diferenciação-e-naive",
    "title": "3  Modelos estatísticos clássicos e diferenciação",
    "section": "3.4 Criando um pipeline com diferenciação e Naive",
    "text": "3.4 Criando um pipeline com diferenciação e Naive\nAgora, podemos criar um modelo de forecasting mais complexo, composto por dois passos:\n\nDiferenciação dos dados\nModelo Naive aplicado nos dados diferenciados\n\nPara isso, usamos a classe TransformedTargetForecaster, que cria um pipeline de transformadores e um modelo de previsão.\n\nfrom sktime.forecasting.compose import TransformedTargetForecaster\n\nmodel = TransformedTargetForecaster(steps=[\n    (\"differencer\", Differencer()),\n    (\"naive\", NaiveForecaster(strategy=\"mean\", window_length=24))\n])\nmodel.fit(y_train)\n\nTransformedTargetForecaster(steps=[('differencer', Differencer()),\n                                   ('naive',\n                                    NaiveForecaster(strategy='mean',\n                                                    window_length=24))])Please rerun this cell to show the HTML repr or trust the notebook.TransformedTargetForecaster?Documentation for TransformedTargetForecasterTransformedTargetForecaster(steps=[('differencer', Differencer()),\n                                   ('naive',\n                                    NaiveForecaster(strategy='mean',\n                                                    window_length=24))])Differencer?Documentation for DifferencerDifferencer()NaiveForecaster?Documentation for NaiveForecasterNaiveForecaster(strategy='mean', window_length=24)\n\n\nOu apenas:\n\nmodel = Differencer() * NaiveForecaster(strategy=\"mean\", window_length=24)\nmodel.fit(y_train)\n\nTransformedTargetForecaster(steps=[Differencer(),\n                                   NaiveForecaster(strategy='mean',\n                                                   window_length=24)])Please rerun this cell to show the HTML repr or trust the notebook.TransformedTargetForecaster?Documentation for TransformedTargetForecasterTransformedTargetForecaster(steps=[Differencer(),\n                                   NaiveForecaster(strategy='mean',\n                                                   window_length=24)])Differencer?Documentation for DifferencerDifferencer()NaiveForecaster?Documentation for NaiveForecasterNaiveForecaster(strategy='mean', window_length=24)\n\n\nE agora podemos prever:\n\ny_pred = model.predict(fh=y_test.index)\nplot_series(y_train, y_test, y_pred, labels=[\"Treino\", \"Teste\", \"Previsão Naive com diferenciação\"])\n\n\n\n\n\n\n\n\nExistem ainda alguns problemas com a diferenciação. Note que a variância da série temporal diferenciada não é constante ao longo do tempo. Vamos ver na próxima seção como lidar com isso.",
    "crumbs": [
      "Part I: Básico",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Modelos estatísticos clássicos e diferenciação</span>"
    ]
  },
  {
    "objectID": "content/pt/part1/statistical_models_differentiation.html#componentes-de-séries-temporais",
    "href": "content/pt/part1/statistical_models_differentiation.html#componentes-de-séries-temporais",
    "title": "3  Modelos estatísticos clássicos e diferenciação",
    "section": "3.2 Componentes de séries temporais",
    "text": "3.2 Componentes de séries temporais\nSéries temporais podem ser decompostas em 3 componentes principais:\n\nTendência: padrão de longo prazo na série temporal\nSazonalidade: padrões que se repetem em intervalos regulares, como diariamente, semanalmente ou anualmente\nRuído: variação aleatória que não pode ser explicada pelos outros componentes\n\nUma série aditiva pode ser representada como:\n\\[\nY(t) = T(t) + S(t) + R(t)\n\\]\nonde \\(T(t)\\) é a tendência, \\(S(t)\\) é a sazonalidade, e \\(R(t)\\) é o ruído.\nEm séries aditivas, o impacto da sazonalidade se dá em termos absolutos, dizemos: “em janeiro, as vendas aumentam em 100 unidades com relação a média do ano”.\nMas também existem séries multiplicativas, onde os componentes interagem de forma diferente:\n\\[\nY(t) = T(t) \\cdot S(t) \\cdot R(t)\n\\]\nNessas séries, o impacto da sazonalidade se dá em termos relativos, dizemos: “em janeiro, as vendas aumentam em 20% com relação a média do ano”. Esse é o caso mais comum para séries não-negativas, como vendas. Isso vem por definição: se temos vendas muito baixas, por exemplo, 10 unidades, não faz sentido dizer que em janeiro as vendas diminuem em 100 unidades, pois isso levaria a vendas negativas. Já dizer que as vendas diminuem em 20% é perfeitamente razoável.\n\n\n\n\n\n\nTip\n\n\n\nEm alguns casos, as séries multiplicativas são definidas como:\n\\[\nY(t) = T(t) + T(t) \\cdot S(t) + T(t) \\cdot R(t)\n\\]\n\n\nQuando a série é multiplicativa, podemos fazer recurso ao logaritmo para transformá-la em aditiva:\n\\[\nlog(Y(t)) = log(T(t)) + log(S(t)) + log(R(t))\n\\]\nPara fazer isso no sktime, usamos o transformador LogTransformer. Transformadores são usados para pré-processar ou pós-processar os dados antes de aplicar um modelo de previsão, e sua interface é similar a dos modelos de previsão:\n\n__init__: define os hiperparâmetros do transformador\nfit: aprende os parâmetros do transformador a partir dos dados\ntransform: aplica a transformação nos dados\ninverse_transform (opcional): aplica a transformação inversa nos dados\n\n\nfrom sktime.transformations.series.boxcox import LogTransformer\nlog_transformer = LogTransformer()\nlog_transformer.fit(y_train)\n\nLogTransformer()Please rerun this cell to show the HTML repr or trust the notebook.LogTransformer?Documentation for LogTransformerLogTransformer()\n\n\n\ny_train_log = log_transformer.transform(y_train)\nplot_series(y_train_log, labels=[\"Logaritmo\"])\n\n\n\n\n\n\n\n\nExistem casos que as séries não são nem aditivas nem multiplicativas. Nesses casos, podemos usar transformações como Box-Cox estabilizar a variância da série temporal. Essas transformações são mais gerais que o logaritmo, e podem ser aplicadas em séries com valores negativos (Yeo-Johnson).\n\nfrom sktime.transformations.series.boxcox import BoxCoxTransformer\n\nboxcox_transformer = BoxCoxTransformer()\nboxcox_transformer.fit(y_train)\n\nBoxCoxTransformer()Please rerun this cell to show the HTML repr or trust the notebook.BoxCoxTransformer?Documentation for BoxCoxTransformerBoxCoxTransformer()\n\n\n\ny_train_boxcox = boxcox_transformer.transform(y_train)\nplot_series(y_train_boxcox, labels=[\"Box-Cox\"])",
    "crumbs": [
      "Part I: Básico",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Modelos estatísticos clássicos e diferenciação</span>"
    ]
  }
]